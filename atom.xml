<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Longlongyu的个人站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://longlongyu.github.io/"/>
  <updated>2018-07-23T19:46:41.243Z</updated>
  <id>https://longlongyu.github.io/</id>
  
  <author>
    <name>Longlongyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对line-height的一些理解</title>
    <link href="https://longlongyu.github.io/2018/07/23/DeepUnderstandingLineHeight/"/>
    <id>https://longlongyu.github.io/2018/07/23/DeepUnderstandingLineHeight/</id>
    <published>2018-07-23T14:21:53.000Z</published>
    <updated>2018-07-23T19:46:41.243Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>line-height</em></strong> 顾名思义就是 <strong>行高</strong>，是用来设置行间的距离，她确实是发挥这样着<br>作用，但单单这样的去理解却也太过于粗浅了。</p><p>首先，具体先了解一下一些相关的概念。想一想在我们在刚开始学习英语课时，老师在黑板上画了<br>四条线，这四条线是英文字母用来书写时的4根横向的平行线，而 <code>vertical-align</code> 中的 <strong>top</strong> , <strong>middle</strong> ,<br><strong>baseline</strong> , <strong>bottom</strong> 就是基于这样的概念。</p><p>接下来我们看看 <strong><em>MDN</em></strong> 对 <strong><em>line-height</em></strong> 的描述，他是这样的：</p><blockquote><p>The <code>line-height</code> CSS property sets the amount of space used for<br>lines, such as in text. On block-level elements, it specifies<br>the minimum height of line boxes within the element. On non-<br>replaced inline elements, it specifies the height that is used<br>to calculate line box height.</p></blockquote><p><code>line-height</code> <strong><em>CSS</em></strong> 属性用于设置多行元素的空间量什么的，这些什么的先不考虑。在上面说明中，涉及到<br>两个很重要的概念，<code>line boxes</code> 和 <code>inline boxes</code> 。</p><a id="more"></a><h1 id="inline-boxes模型"><a href="#inline-boxes模型" class="headerlink" title="inline boxes模型"></a>inline boxes模型</h1><p>我们先说说 <code>inline boxes</code> ，不过在这之前我们的先聊下盒子。说到盒子，我们很容易联想到 <strong>block</strong> 的块级盒<br>子，<strong>inline</strong> 行内盒子，以及两者之间的 <strong>inline-block</strong> 的行内块级盒子。他们的形成也是因为我们使用了所<br>对应的标签，而这些是我们所知很容易了解到的。但请想一想，在这之下是否还有盒子存在呢？例如我们写在盒子<br>中的文字属于盒子吗？属于哪种盒子？</p><p>是的，他们属于盒子。我们都知道行级盒子是在同行进行排列的。一行内这些盒子无论大小都是 <code>inline boxes</code> 。由<br> <strong>inline-block</strong> 和 <strong>inline</strong> 生成的是具名的 <code>inline box</code> ，而文字则是匿名的 <code>inline box</code> 。</p><h1 id="line-boxes模型"><a href="#line-boxes模型" class="headerlink" title="line boxes模型"></a>line boxes模型</h1><p>在了解了 <code>inline boxes</code> ，先不着急，先了解 <code>line boxes</code> 。不过 ，<code>line boxes</code> 到底是个啥呢？</p><p>简单来说 <code>line box</code> 就是包含一行内若干个 <code>inline boxes</code> 的盒子。而这些 <code>inline boxes</code> 中最高的盒子会<br>撑起 <code>line box</code> 的高度。没有指定高度的块级元素和行内块级元素其高度就是由这些 <code>line boxes</code> 累积堆起来<br>的，而除此之外，<code>line boxes</code> 不具有其他特性。</p><h1 id="line-height与line-boxes高度"><a href="#line-height与line-boxes高度" class="headerlink" title="line-height与line boxes高度"></a>line-height与line boxes高度</h1><p>在知道上面的两个概念之后，我们来探讨一些相关的问题。</p><p>一个空的 <strong>div</strong> 在没有设置至少大于1像素高度 <strong>height</strong> 值时，他的高度为0。但如果在里面输入一个<br>文字后，<strong>div</strong> 却拥有高度了。可为什么 <strong>div</strong> 里面有文字后就会有高度呢？</p><p>可能有人会觉得是因为文字大小关系，文字占据空间，从而使 <strong>div</strong> 拥有了高度。然后事实确是，文字<br>并没有撑开了 <strong>div</strong> 的高度，而是 <code>line-height</code> ！</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/longlongyu/j4m0wu8c/embedded/html,css,result/dark" frameborder="0" allowfullscreen></iframe><p>结果是显而易见，是 <code>line-height</code> 撑开了 <strong>div</strong> 的高度。如果你还是感到疑问，还可以看看下面的<br>例子，通过结合上面所说的两个模型更加容易理解。</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/longlongyu/bwjLfovs/39/embedded/html,css,result/dark" frameborder="0" allowfullscreen></iframe><h1 id="line-height与img被div包裹产生的空隙"><a href="#line-height与img被div包裹产生的空隙" class="headerlink" title="line-height与img被div包裹产生的空隙"></a>line-height与img被div包裹产生的空隙</h1><p>相信大家在撰写样式的过程中，一定遇到过这个现象，用 <strong>div</strong> 包裹着一张图片， <strong>div</strong> 却并没有将<br>其完美的包裹起来，而是留有一条小小的空隙。那么，为什么发生这种现象呢？</p><p>通过上面的概念我们就明白这是为什么了。首先我们知道 <strong>img</strong> 即是行内元素也是可替换元素<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Replaced_element" title="Replaced Element" target="_blank" rel="noopener">(Replaced Element)</a><br>，在默认时，文本是按照基线进行对齐的，<strong>img</strong> 在这里是独居一行的 <code>line box</code> ，而 <code>line boxes</code> 通过<br><code>line-height</code> 撑起了盒子的高度，同时由于 <strong>img</strong> 是可替换元素，拥有着自己的 <strong>height</strong> ，两者加算，<br>就产生出了空隙。</p><p>解决方法也很简单，换一种对齐方式就可以解决这个问题了。<code>line-height: 0</code> 也行，但可能会引发<br>诸多问题。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文主要讲述了一些自己对 <code>line-height</code> 和 <code>inline box</code> 模型的理解，对 <code>line-height</code> 的基础的知识<br>并没有进行累述，如果有纰漏之处，欢迎指正。还有兴趣想了解更多相关知识的，可以看看张鑫旭大神的<a href="http://www.cssworld.cn/" target="_blank" rel="noopener">《CSS世界》</a>，<br>里面有更加详细的讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;line-height&lt;/em&gt;&lt;/strong&gt; 顾名思义就是 &lt;strong&gt;行高&lt;/strong&gt;，是用来设置行间的距离，她确实是发挥这样着&lt;br&gt;作用，但单单这样的去理解却也太过于粗浅了。&lt;/p&gt;
&lt;p&gt;首先，具体先了解一下一些相关的概念。想一想在我们在刚开始学习英语课时，老师在黑板上画了&lt;br&gt;四条线，这四条线是英文字母用来书写时的4根横向的平行线，而 &lt;code&gt;vertical-align&lt;/code&gt; 中的 &lt;strong&gt;top&lt;/strong&gt; , &lt;strong&gt;middle&lt;/strong&gt; ,&lt;br&gt;&lt;strong&gt;baseline&lt;/strong&gt; , &lt;strong&gt;bottom&lt;/strong&gt; 就是基于这样的概念。&lt;/p&gt;
&lt;p&gt;接下来我们看看 &lt;strong&gt;&lt;em&gt;MDN&lt;/em&gt;&lt;/strong&gt; 对 &lt;strong&gt;&lt;em&gt;line-height&lt;/em&gt;&lt;/strong&gt; 的描述，他是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;line-height&lt;/code&gt; CSS property sets the amount of space used for&lt;br&gt;lines, such as in text. On block-level elements, it specifies&lt;br&gt;the minimum height of line boxes within the element. On non-&lt;br&gt;replaced inline elements, it specifies the height that is used&lt;br&gt;to calculate line box height.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;line-height&lt;/code&gt; &lt;strong&gt;&lt;em&gt;CSS&lt;/em&gt;&lt;/strong&gt; 属性用于设置多行元素的空间量什么的，这些什么的先不考虑。在上面说明中，涉及到&lt;br&gt;两个很重要的概念，&lt;code&gt;line boxes&lt;/code&gt; 和 &lt;code&gt;inline boxes&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="learn" scheme="https://longlongyu.github.io/tags/learn/"/>
    
      <category term="CSS" scheme="https://longlongyu.github.io/tags/CSS/"/>
    
      <category term="line-height" scheme="https://longlongyu.github.io/tags/line-height/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-Cxo</title>
    <link href="https://longlongyu.github.io/2018/07/18/hexoThemeCxo/"/>
    <id>https://longlongyu.github.io/2018/07/18/hexoThemeCxo/</id>
    <published>2018-07-18T09:40:09.000Z</published>
    <updated>2018-07-23T20:08:40.287Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/demo/demo.png" alt="Cxo"></p><p>如果你喜欢这款主题，可以访问GITHUB地址：<a href="https://github.com/Longlongyu/hexo-theme-Cxo" title="hexo-theme-Cxo" target="_blank" rel="noopener">点这里</a></p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>遇到任何使用上的问题，都可以向我留言。</p><p>感谢您的使用！</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/demo/demo.png&quot; alt=&quot;Cxo&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你喜欢这款主题，可以访问GITHUB地址：&lt;a href=&quot;https://github.com/Longlongyu/hexo-theme-Cxo&quot; title=&quot;hexo-theme-Cxo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;帮助&quot;&gt;&lt;a href=&quot;#帮助&quot; class=&quot;headerlink&quot; title=&quot;帮助&quot;&gt;&lt;/a&gt;帮助&lt;/h2&gt;&lt;p&gt;遇到任何使用上的问题，都可以向我留言。&lt;/p&gt;
&lt;p&gt;感谢您的使用！&lt;/p&gt;
    
    </summary>
    
    
      <category term="theme" scheme="https://longlongyu.github.io/tags/theme/"/>
    
      <category term="hexo" scheme="https://longlongyu.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Express来开发项目</title>
    <link href="https://longlongyu.github.io/2018/06/28/Exercise/"/>
    <id>https://longlongyu.github.io/2018/06/28/Exercise/</id>
    <published>2018-06-28T06:39:37.000Z</published>
    <updated>2018-07-23T13:49:09.861Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Express</em></strong> 是一个基于 <strong><em>Node.js</em></strong> 平台的 <strong><em>web</em></strong> 应用开发框架，它提供一系列强大的特性，可以帮助开发者创建各种 <strong><em>web</em></strong> 和移动设备应用。<br>用 <strong><em>Express</em></strong> 框架开发 <strong><em>web</em></strong> 项目可以直接构建整个项目框架并且将前端页面跟后台贯穿起来。</p><p>是一款高度包容、快速而极简的 <strong><em>Node.js Web</em></strong> 框架。</p><p><img src="https://cdn-images-1.medium.com/max/701/1*EKW3XazCN98jcVrlEP3H8g.png" alt="expressjs"></p><a id="more"></a><h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p><strong><em>Express</em></strong> 是基于 <strong><em>Node.js</em></strong> 的，所以 <strong><em>Node.js</em></strong> 的安装必不可少，不过因为之前通过 <strong><em>hexo</em></strong> 来架构博客的原因，我的电脑已经安装了。</p><p><img src="/img/assets/nodejs.png" alt="nodejs"></p><h2 id="用npm安装express"><a href="#用npm安装express" class="headerlink" title="用npm安装express"></a>用npm安装express</h2><p><strong><em>npm</em></strong> 是随同 <strong><em>Node.js</em></strong> 一起安装的包管理工具，可以用来安装卸载一些 <strong><em>api</em></strong> 包。<br>使用命令行工具<code>$ npm install (要安装的包)</code>进行本地安装，可以加上<code>-g</code>或者<code>--global</code>进行全局安装。<br>这里执行命令<code>$ npm install express</code>就行。</p><hr><h1 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h1><h2 id="使用express来新建项目框架"><a href="#使用express来新建项目框架" class="headerlink" title="使用express来新建项目框架"></a>使用express来新建项目框架</h2><p><code>cd</code>进入想要建项目的文件夹，执行<code>$ express (项目名称)</code>，会在该目录下创建一个新的你所命名的项目工程。<br>这里我执行的是<code>$ express yiyun --pug --css sass</code>，因为我这里使用了 <strong><em>pug</em></strong> 和 <strong><em>sass</em></strong> 来协助项目开发。   </p><p><strong>关于项目框架的说明</strong></p><blockquote><p>/bin: www  文件用于应用启动<br>/public: 静态资源目录：用来放置项目资源文件的<br>/routes: 路由，是项目的控制器，不过我对其了解不太深，是学习的重点之一<br>/views: view(视图)目录，用来放置前端页面的样式<br>app.js：程序的主文件夹，目前项目中有用到的就是添加新的页面以及页面相应的路由需要在这里配置<br>package.json：项目中用到的一些包的版本信息</p></blockquote><h2 id="试运行项目"><a href="#试运行项目" class="headerlink" title="试运行项目"></a>试运行项目</h2><p>项目创建好了之后，用命令行进入项目根目录，然后用<code>npm i</code>命令会安装 <strong><em>package.json</em></strong> 中的依赖项目。<br>通过执行<code>$ npm start</code>启动项目，到浏览器输入：<strong><em>localhost:3000</em></strong>，看到 <strong><em>Express</em></strong> 说明成功运行。</p><hr><h1 id="更好的开发体验"><a href="#更好的开发体验" class="headerlink" title="更好的开发体验"></a>更好的开发体验</h1><p>在编写项目的过程中，对代码进行调试时，每次调试时都需要关闭服务器才能进行重新刷新页面。<br>可以说对开发有着极大的不便，我们需要一些工具来让帮助我们有更好的开发体验。</p><h2 id="Express的debug模块"><a href="#Express的debug模块" class="headerlink" title="Express的debug模块"></a>Express的debug模块</h2><p>命令行输入<code>$ DEBUG=(项目名称):* npm start</code>就能执行 <strong><em>express</em></strong> 的 <strong><em>debug</em></strong> 模块。</p><h2 id="使用babel来写ES6"><a href="#使用babel来写ES6" class="headerlink" title="使用babel来写ES6"></a>使用babel来写ES6</h2><p>我在编写项目的 <strong><em>javascript</em></strong> 时，使用了 <strong><em>ES6</em></strong> 标准来撰写代码，但是目前的浏览器不支持大多的 <strong><em>ES6</em></strong> 标准，<br>这时候需要一款工具 <strong><em>babel</em></strong> 来帮助我们，<strong><em>babel</em></strong> 可以将 <strong><em>ES6</em></strong> 的代码转换为 <strong><em>ES5</em></strong> 标准，在当下 <strong><em>ES6</em></strong> 还没有在浏览器普及的今天，这可是大利器。</p><p>执行<code>$ npm install -g --save-dev babel-cli babel-core babel-plugin-transform-runtime babel-preset-es2015</code><br><strong><em>babel</em></strong> 已经在我们的项目中创建好了，这里的参数<code>--save-dev</code>会将所下载的工具保存到 <strong><em>package.json</em></strong> 的依赖项目中。</p><p>新建文件 <strong><em>.babelrc</em></strong> 并且写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据需求在命令行输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 转码结果输出到标准输出</span><br><span class="line"><span class="meta">$</span> babel example.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 转码结果写入一个文件</span><br><span class="line"><span class="meta">#</span> --out-file 或 -o 参数指定输出文件</span><br><span class="line"><span class="meta">$</span> babel example.js --out-file compiled.js</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 整个目录转码</span><br><span class="line"><span class="meta">#</span> --out-dir 或 -d 参数指定输出目录</span><br><span class="line"><span class="meta">$</span> babel src --out-dir lib</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> -s 参数生成source map文件</span><br><span class="line"><span class="meta">$</span> babel src -d lib -s</span><br></pre></td></tr></table></figure><p>这样就可以简单地运行 <strong><em>babel</em></strong> 了。</p><h2 id="搭配webpack来开发"><a href="#搭配webpack来开发" class="headerlink" title="搭配webpack来开发"></a>搭配webpack来开发</h2><p>虽然可以编写 <strong><em>ES6</em></strong> 的代码了，但开发友好度依然不好，而且在调试的时候依然遇到了问题。   </p><p><code>Uncaught ReferenceError: require is not defined</code></p><p>再查看一下错误位置，发现出现错误的原因是因为我们使用了 <strong><em>import</em></strong> 和 <strong><em>export</em></strong> ，<strong><em>babel</em></strong> 对其只是进行了翻译，并不会合并代码的内容。所以我们需要另一项工具———— <strong><em>webpack</em></strong>。</p><p><strong><em>webpack</em></strong> 是一个模块打包器。<strong><em>webpack</em></strong> 的主要目标是将 <strong><em>JavaScript</em></strong> 文件打包在一起，将打包后的文件用于在浏览器中使用。</p><p>并且我们使用了 <strong><em>babel</em></strong> ，需要使用 <code>babel-loader</code> 来更好协助打包。</p><p>了解用途后，来命令行执行<code>$ npm install -g --save-dev webpack webpack-cli babel-loader</code></p><p>新建<code>webpack.config.js</code>文件，并对其进行配置   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry : &#123;</span><br><span class="line">main : <span class="string">'./src/js/main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output : &#123;</span><br><span class="line"><span class="comment">//__dirname，就是当前webpack.config.js文件所在的绝对路径</span></span><br><span class="line">filename : <span class="string">'[name].js'</span>,</span><br><span class="line">path : path.join(__dirname, <span class="string">'./public/javascripts'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  mode:<span class="string">"development"</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  query: &#123;</span><br><span class="line"><span class="string">'presets'</span>: [<span class="string">'es2015'</span>],</span><br><span class="line">plugins : [<span class="string">'transform-runtime'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后在 <strong><em>package.json</em></strong> 里编辑命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack -w"</span>,</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"node ./bin/www"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成，另开一个命令行，分别执行<code>$ npm run dev</code>和<code>$ DEBUG=yiyun:* npm start</code>，现在 <strong><em>webpack</em></strong> 会监视 <strong><em>js</em></strong> 的改动，并重新发布成 <strong><em>main.js</em></strong>，代码修改后只需要刷新浏览器就可以进行调试了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;Express&lt;/em&gt;&lt;/strong&gt; 是一个基于 &lt;strong&gt;&lt;em&gt;Node.js&lt;/em&gt;&lt;/strong&gt; 平台的 &lt;strong&gt;&lt;em&gt;web&lt;/em&gt;&lt;/strong&gt; 应用开发框架，它提供一系列强大的特性，可以帮助开发者创建各种 &lt;strong&gt;&lt;em&gt;web&lt;/em&gt;&lt;/strong&gt; 和移动设备应用。&lt;br&gt;用 &lt;strong&gt;&lt;em&gt;Express&lt;/em&gt;&lt;/strong&gt; 框架开发 &lt;strong&gt;&lt;em&gt;web&lt;/em&gt;&lt;/strong&gt; 项目可以直接构建整个项目框架并且将前端页面跟后台贯穿起来。&lt;/p&gt;
&lt;p&gt;是一款高度包容、快速而极简的 &lt;strong&gt;&lt;em&gt;Node.js Web&lt;/em&gt;&lt;/strong&gt; 框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/701/1*EKW3XazCN98jcVrlEP3H8g.png&quot; alt=&quot;expressjs&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="learn" scheme="https://longlongyu.github.io/tags/learn/"/>
    
      <category term="express" scheme="https://longlongyu.github.io/tags/express/"/>
    
      <category term="webpack" scheme="https://longlongyu.github.io/tags/webpack/"/>
    
      <category term="babel" scheme="https://longlongyu.github.io/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>Hello-Hexo!</title>
    <link href="https://longlongyu.github.io/2018/06/20/HelloWorld/"/>
    <id>https://longlongyu.github.io/2018/06/20/HelloWorld/</id>
    <published>2018-06-20T06:39:37.000Z</published>
    <updated>2018-07-15T01:54:58.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello，Hexo"><a href="#Hello，Hexo" class="headerlink" title="Hello，Hexo!"></a>Hello，Hexo!</h1><p>使用了Github提供的个人页和Hexo博客框架搭建的博客。</p><p>希望可以利用这个平台更好的学习激励自己，多记录自己学习经历。</p><p><img src="/img/assets/hexo.jpg" alt="hexo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hello，Hexo&quot;&gt;&lt;a href=&quot;#Hello，Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hello，Hexo!&quot;&gt;&lt;/a&gt;Hello，Hexo!&lt;/h1&gt;&lt;p&gt;使用了Github提供的个人页和Hexo博客框架搭建的博客。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="learn" scheme="https://longlongyu.github.io/tags/learn/"/>
    
  </entry>
  
</feed>
